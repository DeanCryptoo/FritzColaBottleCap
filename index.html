<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>fritz-kola | DECKEL SCHNIPPEN</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anton&family=Inter:wght@400;600&display=swap');

        :root {
            --bg: #000000;
            --white: #f1f1f1;
            --red: #c91a1a;
            --font-head: 'Anton', sans-serif;
            --font-body: 'Inter', sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg);
            color: var(--white);
            font-family: var(--font-body);
            overflow: hidden;
            height: 100vh; width: 100vw;
            display: flex; justify-content: center; align-items: center;
            touch-action: none; 
        }

        #game-container {
            position: relative; 
            width: 100%; 
            height: 100%;
            max-width: 480px; 
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 50px rgba(20, 20, 20, 0.5); 
        }

        canvas { display: block; width: 100%; height: 100%; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }

        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #fff; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            font-family: var(--font-head); font-size: 2rem;
            transition: opacity 0.5s;
        }

        header {
            position: absolute; top: 0; left: 0; width: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding-top: 40px; z-index: 50; pointer-events: none; 
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1; transform: translateY(0);
        }
        header.hidden-ui { opacity: 0; transform: translateY(-20px); }

        .logo { font-family: var(--font-head); font-size: 3rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 4px 20px rgba(0,0,0,0.8); }
        .red { color: var(--red); }
        
        #score-box {
            font-family: var(--font-head); font-size: 1.5rem; color: #ccc;
            margin-top: 5px; letter-spacing: 1px; text-shadow: 0 2px 4px #000;
        }
        #score-val { color: var(--white); font-size: 2.2rem; }
        .pulse-text { animation: pulse 0.3s ease-in-out; color: var(--red) !important; text-shadow: 0 0 30px var(--red); }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.5); } 100% { transform: scale(1); } }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); 
            display: none; 
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px;
            pointer-events: auto; 
        }
        .screen.active { display: flex; animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        h1 { font-family: var(--font-head); font-size: 3.5rem; margin: 0; line-height: 0.9; text-transform: uppercase; letter-spacing: 1px; }
        h2 { font-family: var(--font-head); font-size: 2rem; margin: 0 0 10px 0; color: var(--white); }
        p { color: #eee; margin: 15px 0 30px 0; max-width: 320px; line-height: 1.4; font-size: 1rem; text-shadow: 0 1px 2px #000; }

        .btn {
            background: var(--white); color: var(--bg); font-family: var(--font-head); font-size: 1.3rem;
            padding: 20px 0; width: 100%; max-width: 280px; border: none; cursor: pointer; text-transform: uppercase; 
            margin: 8px 0;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
            position: relative; pointer-events: auto; user-select: none; transition: transform 0.1s;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }
        .btn:active { transform: scale(0.96); background: #ccc; }
        .btn-outline { background: transparent; color: var(--white); border: 2px solid rgba(255,255,255,0.3); box-shadow: none; }
        .hidden { display: none !important; }

        input { 
            border: 1px solid #333; background: #111; color: #fff; padding: 15px; width: 100%; 
            font-family: monospace; text-align: center; margin-bottom: 10px; font-size: 1.1rem; outline: none; 
            pointer-events: auto; user-select: text; -webkit-user-select: text;
        }

        #tutorial-overlay {
            position: absolute; bottom: 45%; left: 0; width: 100%;
            text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 15;
        }
        #tutorial-overlay.show { opacity: 1; }
        .hand { font-size: 3rem; display: block; animation: flickUp 1.5s infinite; filter: drop-shadow(0 5px 5px #000); }
        .hint { font-family: var(--font-head); font-size: 1.2rem; text-transform: uppercase; text-shadow: 0 2px 4px #000; letter-spacing: 1px; }
        
        @keyframes flickUp { 
            0% { transform: translateY(20px) rotate(0deg); opacity: 0; } 
            20% { opacity: 1; }
            80% { transform: translateY(-40px) rotate(-10deg); opacity: 0; } 
            100% { opacity: 0; } 
        }
    </style>
</head>
<body>

    <div id="loading-screen">LADE BILDER...</div>

    <div id="game-container">
        <header id="main-header" class="hidden-ui">
            <div class="logo">fritz<span class="red">-</span>kola</div>
            <div id="score-box">STREAK: <span id="score-val">0</span> / 10</div>
        </header>

        <div id="game-layer">
            <canvas id="c"></canvas>
            <div id="tutorial-overlay">
                <span class="hand">üëÜ</span>
                <span class="hint">ZUM SCHIE√üEN SCHNIPPEN</span>
            </div>
        </div>

        <div id="ui-layer">
            <div id="s-intro" class="screen active">
                <h1>DECKEL AB</h1>
                <p>Flasche scannen um zu spielen.<br>Schnipp den Deckel in den Eimer.</p>
                <div id="token-status" style="margin-bottom: 20px; font-family: monospace; color: var(--red); font-size: 0.9rem;">Pr√ºfe Token...</div>
                <button class="btn hidden" id="btn-start" ontouchstart="startGame()" onclick="startGame()">SPIEL STARTEN</button>
            </div>

            <div id="s-instant" class="screen">
                <h1 id="iw-title">SAUBER!</h1>
                <p id="iw-msg">Pr√ºfe Sofortgewinn...</p>
                <div id="iw-win-container" class="hidden" style="width: 100%; max-width: 320px;">
                    <h2 style="color: #FFD700;">SHIRT GEWONNEN!</h2>
                    <p>Gib deine E-Mail ein um den Gewinn zu sichern.</p>
                    <input type="email" id="email-instant" placeholder="DEINE E-MAIL ADRESSE">
                    <button class="btn" ontouchstart="claimInstant()" onclick="claimInstant()">GEWINN SICHERN</button>
                </div>
                <div id="iw-loss-container" class="hidden" style="width: 100%; max-width: 320px;">
                    <h2>KEIN SOFORTGEWINN</h2>
                    <p>Aber du kannst noch gro√ü abr√§umen.</p>
                </div>
                <div id="iw-continue-container" class="hidden" style="width: 100%; max-width: 320px; margin-top: 20px; padding-top: 20px; border-top: 1px solid #333;">
                    <h3 style="margin:0 0 10px 0; font-family:var(--font-head); color:var(--white);">DAS GEWINNSPIEL</h3>
                    <p style="margin: 0 0 15px 0; color:#888;">Triff noch 9 Mal in Folge f√ºr die gro√üe Verlosung.</p>
                    <button class="btn" ontouchstart="startStreakMode()" onclick="startStreakMode()">WEITER (NOCH 9)</button>
                    <button class="btn btn-outline" style="margin-top:10px" ontouchstart="location.reload()" onclick="location.reload()">NEIN DANKE</button>
                </div>
            </div>

            <div id="s-fail" class="screen">
                <h1 style="color: #666;">DANEBEN!</h1>
                <p>Die Serie ist gerissen.<br>Dieser Token ist nun verbraucht.</p>
                <button class="btn" ontouchstart="location.reload()" onclick="location.reload()">NEUE FLASCHE SCANNEN</button>
            </div>

            <div id="s-raffle" class="screen">
                <h1 style="color: #FFD700;">LEGEND√ÑR!</h1>
                <p>10 Treffer in Folge.<br>Du bist im Lostopf.</p>
                <div style="width: 100%; max-width: 320px;">
                    <input type="email" id="email-raffle" placeholder="DEINE E-MAIL ADRESSE">
                    <button class="btn" ontouchstart="submitRaffle()" onclick="submitRaffle()">TEILNEHMEN</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const cvs = document.getElementById('c');
        const ctx = cvs.getContext('2d');
        const VH = 1000; 
        const VW = 600;
        let scale = 1; 
        let globalTime = 0; 
        let isPC = false; // Detection flag

        // --- ASSET LOADER (UPDATED FOR DUAL BG) ---
        const images = {};
        const imageSources = {
            bottle: 'Bottle.png',     
            cap: 'BottleCap.png',     
            bucket: 'icebucket.png',  
            bgDesktop: 'backgroundDesktop.jpeg', // NEW
            bgPhone: 'backgroundPhone.jpeg'      // NEW
        };

        // ==========================================
        // === GAME CONFIGURATION ===
        // ==========================================
        const GAME_CONFIG = {
            pc: {
                bottleWidth: 120,     
                bottleBottom: 220,    
                capSize: 32           
            },
            mobile: {
                bottleWidth: 110,     
                bottleBottom: 100,     
                capSize: 30           
            },
            visuals: {
                bgOverlayOpacity: 0.5 
            }
        };

        // --- SECURITY & FUTURE PROOFING ---
        // Keeps track of input data to send to backend for verification
        const SECURITY = {
            startTime: 0,
            startPos: {x:0, y:0},
            shots: [],
            
            recordShot: function(vecX, vecY) {
                this.shots.push({
                    ts: Date.now(),
                    dx: vecX,
                    dy: vecY,
                    valid: true // Backend would verify physics bounds here
                });
            },
            
            getPayload: function() {
                // This is what you would send to your API endpoint
                return JSON.stringify({
                    token: state.token,
                    sessionData: this.shots,
                    finalStreak: state.streak
                });
            }
        };

        // --- PHYSICS CONFIG ---
        const GRAVITY = 0.85;  
        const POWER_X = 0.14;  
        const POWER_Y = 0.16;  
        const SCALE_NEAR = 3.5; 
        const SCALE_FAR = 1.1; 
        
        let CAP_START_Y = VH - 200; 

        let IMG_SIZES = {
            bottle: { w: 100, h: 100 }, 
            cap: { w: 30, h: 30 },      
            bucket: { w: 240, h: 240 }  
        };

        const state = {
            token: null,
            phase: 'idle', 
            mode: 'warmup', 
            streak: 0,
            cameraY: 0,
            cameraShake: 0,
            screenFlash: 0, 
            timeScale: 1.0, 
            freezeFrame: 0, 
            bgEnergy: 0, 
            wonBottles: [],
            shockwaves: [],
            floatTexts: [],
            bgParticles: [],
            // Game Feel Variables
            bottleRecoil: 0 
        };

        const bottle = {
            x: 0, y: 0, w: 22, h: 8, z: SCALE_NEAR, 
            vx: 0, vy: 0, rot: 0, vRot: 0,
            reset: function() {
                this.x = VW / 2; 
                this.y = CAP_START_Y;
                this.z = SCALE_NEAR; 
                this.vx = 0; this.vy = 0; this.rot = 0; this.vRot = 0;
                state.phase = 'idle';
                state.cameraY = 0;
                state.timeScale = 1.0; 
                state.bottleRecoil = 0;
            }
        };

        const bucketObj = {
            x: VW / 2, y: 550, w: IMG_SIZES.bucket.w, h: IMG_SIZES.bucket.h, scale: SCALE_FAR, scaleAnim: 1.0, angle: 0, 
            init: function() { },
            resetPos: function() { this.x = VW/2; this.y = 550; this.angle = 0; },
            update: function() {
                this.scaleAnim += (1.0 - this.scaleAnim) * 0.1;
                if(state.mode === 'streak' && state.streak >= 3) {
                    let speed = 0.0005 + (state.streak * 0.00025);
                    let range = 80 + (state.streak * 6); 
                    this.angle += speed * 16.6 * state.timeScale;
                    this.x = (VW/2) + Math.sin(this.angle) * range;
                }
            }
        };
        bucketObj.init();

        const particles = [];

        function spawnParticles(x, y, type, customColor) {
            let count = type === 'confetti' ? 40 : 20;
            if(type === 'gas') count = 15; // New Gas Type

            for(let i=0; i<count; i++) {
                let color = '#fff';
                let size = Math.random() * 8 + 2;
                let life = 1.0;
                
                if(type === 'confetti') {
                    if(customColor) color = customColor; 
                    else {
                        const cols = ['#fff', '#c91a1a', '#a5f2f3', '#FFD700'];
                        color = cols[Math.floor(Math.random()*cols.length)];
                    }
                } else if (type === 'spark') {
                    color = '#FFD700';
                } else if (type === 'gas') {
                    color = 'rgba(200, 200, 200, 0.4)'; // Smokey
                    size = Math.random() * 15 + 5;
                }

                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5) * (type==='confetti'?25:15),
                    vy: (Math.random()-0.5) * (type==='confetti'?25:15) + (type==='gas'?-5:0), // Gas goes up
                    life: life,
                    type: type,
                    color: color,
                    size: size,
                    rot: Math.random() * Math.PI, 
                    vRot: (Math.random()-0.5) * 0.5 
                });
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.globalAlpha = p.life;
                
                if(p.type === 'splash') {
                    let rad = ctx.createRadialGradient(0,0,0, 0,0,12);
                    rad.addColorStop(0, 'rgba(165, 242, 243, 0.8)');
                    rad.addColorStop(1, 'rgba(165, 242, 243, 0)');
                    ctx.fillStyle = rad;
                    ctx.beginPath(); ctx.arc(0,0, 12, 0, Math.PI*2); ctx.fill();
                } else if (p.type === 'confetti') {
                    ctx.fillStyle = p.color;
                    ctx.rotate(p.rot);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                } else if (p.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(2, 0); ctx.lineTo(0, 8); ctx.lineTo(-2, 0); ctx.fill();
                } else if (p.type === 'gas') {
                    // Gas / Smoke effect
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(0,0, p.size, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            });
        }

        function spawnFloatingText(text, x, y) {
            state.floatTexts.push({ text: text, x: x, y: y, life: 1.0, vy: -2 });
        }

        function drawFloatingTexts() {
            ctx.save();
            ctx.textAlign = 'center';
            state.floatTexts.forEach(t => {
                ctx.font = "bold 40px 'Anton', sans-serif";
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = t.life;
                ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                ctx.strokeText(t.text, t.x, t.y);
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.restore();
        }

        function spawnShockwave(x, y, color) {
            state.shockwaves.push({ x: x, y: y, r: 10, maxR: 800, alpha: 0.8, color: color });
        }

        function updateEffects() {
            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx * state.timeScale; 
                p.y += p.vy * state.timeScale;
                p.life -= 0.03 * state.timeScale;
                
                if(p.type === 'splash') {
                    p.vy += 0.5 * state.timeScale;
                } else if (p.type === 'confetti') {
                    p.vy += 0.5 * state.timeScale;
                    p.rot += p.vRot * state.timeScale; 
                } else if (p.type === 'gas') {
                    p.size *= 1.05; // Gas grows
                    p.life -= 0.02; // Fades faster
                }
                
                if(p.life <= 0) particles.splice(i, 1);
            }
            // Shockwaves
            for(let i=state.shockwaves.length-1; i>=0; i--) {
                let s = state.shockwaves[i];
                s.r += 40; s.alpha -= 0.04; 
                if(s.alpha <= 0) state.shockwaves.splice(i, 1);
            }
            // Texts
            for(let i=state.floatTexts.length-1; i>=0; i--) {
                let t = state.floatTexts[i];
                t.y += t.vy * state.timeScale; t.life -= 0.02 * state.timeScale;
                if(t.life <= 0) state.floatTexts.splice(i, 1);
            }
            
            if(state.screenFlash > 0) state.screenFlash -= 0.1;

            // Recoil recovery
            state.bottleRecoil *= 0.8;
        }

        function triggerHaptic(type) {
            if (!navigator.vibrate) return;
            if (type === 'tension') navigator.vibrate(5); 
            if (type === 'impact') navigator.vibrate(40); 
            if (type === 'success') navigator.vibrate([40, 50, 40, 50, 100]); 
        }

        // --- PRELOADER ---
        function loadAssets() {
            let loaded = 0;
            const keys = Object.keys(imageSources);
            const total = keys.length;
            if(total === 0) { init(); return; }
            keys.forEach(key => {
                const img = new Image();
                img.src = imageSources[key];
                img.onload = () => {
                    loaded++;
                    images[key] = img;
                    if(loaded === total) {
                        document.getElementById('loading-screen').style.opacity = 0;
                        setTimeout(() => {
                            document.getElementById('loading-screen').style.display = 'none';
                            init();
                        }, 500);
                    }
                };
                img.onerror = () => {
                    console.error("Failed to load: " + imageSources[key]);
                    loaded++;
                    if(loaded === total) init();
                };
            });
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Simulating API Check
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            if(token) {
                state.token = token;
                document.getElementById('token-status').innerText = "TOKEN AKTIV";
                document.getElementById('token-status').style.color = "#fff";
                document.getElementById('btn-start').classList.remove('hidden');
            } else {
                state.token = "demo-" + Date.now();
                document.getElementById('token-status').innerText = "DEMO MODUS";
                document.getElementById('token-status').style.color = "#aaa";
                document.getElementById('btn-start').classList.remove('hidden');
            }
            bottle.reset();
            loop();
        }

        function loop() {
            globalTime += 0.05;
            if(state.freezeFrame > 0) {
                state.freezeFrame--;
                requestAnimationFrame(loop);
                return;
            }
            state.bgEnergy *= 0.95; 

            drawBackground();

            ctx.save();
            let offsetX = (cvs.width - (VW * scale)) / 2;
            ctx.translate(offsetX, 0);
            ctx.scale(scale, scale);
            
            // Draw Shockwaves behind everything
            state.shockwaves.forEach(s => {
                ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
                ctx.strokeStyle = s.color; ctx.lineWidth = 30; ctx.globalAlpha = s.alpha; ctx.stroke();
            });
            ctx.restore();
            
            ctx.save();
            ctx.translate(offsetX, 0);
            ctx.scale(scale, scale);

            let shakeX = (Math.random()-0.5) * state.cameraShake;
            let shakeY = (Math.random()-0.5) * state.cameraShake;
            state.cameraShake *= 0.85; 
            ctx.translate(shakeX, state.cameraY + shakeY);

            bucketObj.update();
            let bScale = bucketObj.scale * bucketObj.scaleAnim; 

            ctx.save();
            ctx.translate(bucketObj.x, bucketObj.y);
            ctx.scale(bScale, bScale); 
            drawBucketImage(); 
            drawStoredBottles(); 
            ctx.restore();

            // DRAW STATIONARY BOTTLE BODY (With Recoil)
            ctx.save();
            ctx.translate(VW/2, CAP_START_Y + state.bottleRecoil); // Added Recoil Y
            ctx.scale(SCALE_NEAR, SCALE_NEAR);
            drawStationaryBottle();
            ctx.restore();

            // HANDLE FLYING CAP
            if(state.phase === 'flying') {
                let distTotal = (VH - 150) - bucketObj.y;
                let currentDist = bottle.y - bucketObj.y;
                let progress = Math.max(0, Math.min(1, currentDist / distTotal));
                bottle.z = bucketObj.scale + (progress * (SCALE_NEAR - bucketObj.scale));
            } else if (state.phase === 'idle') {
                bottle.reset(); 
            }

            // Draw Cap 
            if(state.phase !== 'in_bucket' && state.phase !== 'miss_anim_done') {
                ctx.save();
                ctx.translate(bottle.x, bottle.y);
                ctx.scale(bottle.z, bottle.z);
                ctx.rotate(bottle.rot);
                
                let speed = Math.sqrt(bottle.vx*bottle.vx + bottle.vy*bottle.vy);
                if(state.phase === 'flying' && speed > 10) {
                    let offset = speed * 0.4;
                    ctx.save(); ctx.translate(0, offset); ctx.globalAlpha = 0.4; drawCapGraphic(); ctx.restore();
                }
                drawCapGraphic();
                ctx.restore();
            }

            updatePhysics();
            updateEffects();
            drawParticles();
            drawFloatingTexts();

            ctx.restore();

            if(state.screenFlash > 0.05) {
                ctx.fillStyle = `rgba(255,255,255,${state.screenFlash})`;
                ctx.fillRect(0,0,cvs.width, cvs.height);
            }

            requestAnimationFrame(loop);
        }

        // === DUAL BACKGROUND SYSTEM ===
        function drawBackground() {
            let bgImg = isPC ? images.bgDesktop : images.bgPhone;
            
            if(!bgImg) {
                ctx.fillStyle = '#050505';
                ctx.fillRect(0,0,cvs.width, cvs.height);
            } else {
                let bgRatio = bgImg.width / bgImg.height;
                let cvsRatio = cvs.width / cvs.height;
                
                if (cvsRatio > bgRatio) {
                    let newH = cvs.width / bgRatio;
                    ctx.drawImage(bgImg, 0, (cvs.height - newH)/2, cvs.width, newH);
                } else {
                    let newW = cvs.height * bgRatio;
                    ctx.drawImage(bgImg, (cvs.width - newW)/2, 0, newW, cvs.height);
                }
            }

            ctx.fillStyle = `rgba(0, 0, 0, ${GAME_CONFIG.visuals.bgOverlayOpacity})`; 
            ctx.fillRect(0, 0, cvs.width, cvs.height);
        }

        function updatePhysics() {
            if(state.phase !== 'flying') return;

            let distToBucket = Math.sqrt(Math.pow(bottle.x - bucketObj.x, 2) + Math.pow(bottle.y - bucketObj.y, 2));
            
            if(distToBucket < 220 && Math.abs(bottle.y - bucketObj.y) < 180 && bottle.vy > 0) {
                state.timeScale += (0.35 - state.timeScale) * 0.15; 
                if(Math.random() > 0.8) triggerHaptic('tension');
            } else {
                state.timeScale += (1.0 - state.timeScale) * 0.1; 
            }

            bottle.vy += GRAVITY * state.timeScale; 
            bottle.x += bottle.vx * state.timeScale;
            bottle.y += bottle.vy * state.timeScale;
            bottle.rot += bottle.vRot * state.timeScale;

            if(bottle.y > VH + 200 || bottle.x < -100 || bottle.x > VW + 100) {
                handleMiss();
            }

            let targetY = bucketObj.y - (bucketObj.h * bucketObj.scale)/2;
            let rimW = bucketObj.w * bucketObj.scale;

            if(Math.abs(bottle.y - targetY) < 50 && bottle.vy > 0) {
                if(Math.abs(bottle.x - bucketObj.x) < rimW/2 + 15) {
                    handleScore();
                } else if (Math.abs(bottle.x - bucketObj.x) < rimW/2 + 35) {
                    bottle.vx *= -0.6;
                    bottle.vRot += (Math.random()-0.5) * 5; 
                    state.cameraShake = 30; 
                    state.freezeFrame = 4;
                    spawnParticles(bottle.x, bottle.y, 'spark'); 
                    triggerHaptic('impact');
                }
            }
        }

        function handleScore() {
            state.phase = 'in_bucket';
            bottle.vx = 0; bottle.vy = 0; 
            
            state.bgEnergy = 150; 
            state.cameraShake = 40; 
            state.screenFlash = 0.4; 
            state.freezeFrame = 8; 
            bucketObj.scaleAnim = 1.2; 
            triggerHaptic('success');
            
            spawnParticles(bucketObj.x, bucketObj.y - 50, 'splash'); 
            
            let waveColor = '#fff';
            if(state.streak >= 4) waveColor = '#a5f2f3'; // Blue
            if(state.streak >= 8) waveColor = '#c91a1a'; // Red
            
            spawnParticles(bucketObj.x, bucketObj.y - 100, 'confetti', waveColor); 
            spawnShockwave(bucketObj.x, bucketObj.y, waveColor);

            if(state.mode === 'streak') {
                state.streak++;
                let scoreEl = document.getElementById('score-val');
                scoreEl.innerText = state.streak;
                scoreEl.classList.remove('pulse-text');
                void scoreEl.offsetWidth; 
                scoreEl.classList.add('pulse-text');
                
                let msgs = ["SAUBER!", "GLATT!", "REIN!", "PERFEKT!"];
                let msg = msgs[Math.floor(Math.random()*msgs.length)];
                if(state.streak % 5 === 0) msg = "LEGEND√ÑR!";
                spawnFloatingText(msg, bucketObj.x, bucketObj.y - 150);
            } else {
                spawnFloatingText("TREFFER!", bucketObj.x, bucketObj.y - 150);
            }

            // MOCK: Send Payload to server
            console.log("SENDING SECURE SCORE:", SECURITY.getPayload());

            setTimeout(() => {
                let baseHeight = -10; 
                let stackHeight = state.wonBottles.length * 15; 
                state.wonBottles.push({
                    relX: (Math.random() - 0.5) * 80, 
                    relY: baseHeight - stackHeight + (Math.random() * 10), 
                    rot: (Math.random() - 0.5) * 2.0 
                });
                if(state.mode === 'warmup') {
                    showInstantWinCheck();
                } else if (state.mode === 'streak') {
                    if(state.streak >= 10) showScreen('s-raffle');
                    else {
                        bottle.reset();
                    }
                }
            }, 600);
        }

        function handleMiss() {
            state.phase = 'miss';
            setTimeout(() => {
                if(state.mode === 'warmup') bottle.reset();
                else showScreen('s-fail');
            }, 500);
        }

        function drawBucketImage() {
            if(images.bucket) {
                let w = IMG_SIZES.bucket.w;
                let h = IMG_SIZES.bucket.h;
                ctx.drawImage(images.bucket, -w/2, -h/2, w, h);
            }
        }

        function drawStoredBottles() {
            state.wonBottles.forEach(b => {
                ctx.save();
                ctx.translate(b.relX, b.relY); 
                ctx.rotate(b.rot);
                ctx.scale(1.2, 1.2); 
                drawCapGraphic(); 
                ctx.restore();
            });
        }

        function drawStationaryBottle() {
            if(images.bottle) {
                let w = IMG_SIZES.bottle.w;
                let h = IMG_SIZES.bottle.h;
                ctx.drawImage(images.bottle, -w/2, -10, w, h); 
            }
        }

        function drawCapGraphic() {
            if(images.cap) {
                let w = IMG_SIZES.cap.w;
                let h = IMG_SIZES.cap.h;
                ctx.drawImage(images.cap, -w/2, -h/2, w, h);
            }
        }

        const input = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

        function handleInputStart(x, y) {
            if(state.phase !== 'idle') return;
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            
            let relativeX = x - rect.left;
            let relativeY = y - rect.top;

            let offsetX = (cvs.width - (VW * scale)) / 2;
            let virtX = (relativeX - offsetX) / scale;
            let virtY = relativeY / scale;

            if(virtY > VH / 2) {
                input.active = true;
                input.startX = virtX;
                input.startY = virtY;
                input.currX = virtX;
                input.currY = virtY;
                state.phase = 'aiming'; 
                document.getElementById('tutorial-overlay').classList.remove('show');
                
                // SECURITY: Log Start
                SECURITY.startTime = Date.now();
                SECURITY.startPos = {x: virtX, y: virtY};
            }
        }

        function handleInputMove(x, y) {
            if(!input.active) return;
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            let relativeX = x - rect.left;
            let relativeY = y - rect.top;
            let offsetX = (cvs.width - (VW * scale)) / 2;
            input.currX = (relativeX - offsetX) / scale;
            input.currY = relativeY / scale;
        }

        function handleInputEnd() {
            if(!input.active) return;
            input.active = false;
            
            let dx = input.currX - input.startX;
            let dy = input.currY - input.startY;
            
            // Swipe UP logic
            if(dy < -30) { 
                state.phase = 'flying';
                bottle.vx = dx * POWER_X; 
                bottle.vy = dy * POWER_Y; 
                bottle.vRot = (Math.random() - 0.5) * 0.8; 
                
                // GAME FEEL: FRITZ ZISCH
                // Spawn gas particles at the bottle neck (center of screen, CAP_START_Y)
                spawnParticles(VW/2, CAP_START_Y, 'gas');
                
                // GAME FEEL: BOTTLE RECOIL
                state.bottleRecoil = 25; // Push bottle down

                // SECURITY: Log Shot
                SECURITY.recordShot(bottle.vx, bottle.vy);
            } else {
                state.phase = 'idle'; 
            }
        }

        window.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleInputEnd);
        window.addEventListener('touchstart', e => { 
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            e.preventDefault(); handleInputStart(e.touches[0].clientX, e.touches[0].clientY); 
        }, {passive:false});
        window.addEventListener('touchmove', e => { 
            if(input.active) e.preventDefault(); handleInputMove(e.touches[0].clientX, e.touches[0].clientY); 
        }, {passive:false});
        window.addEventListener('touchend', handleInputEnd);

        const header = document.getElementById('main-header');

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            if(id) {
                document.getElementById(id).classList.add('active');
                header.classList.add('hidden-ui'); 
            } else {
                header.classList.remove('hidden-ui'); 
            }
        }

        function startGame() { showScreen(''); document.getElementById('tutorial-overlay').classList.add('show'); }
        function showInstantWinCheck() { 
            showScreen('s-instant'); 
            const isWinner = Math.random() < 0.3; 
            setTimeout(() => {
                document.getElementById('iw-msg').classList.add('hidden');
                if(isWinner) document.getElementById('iw-win-container').classList.remove('hidden');
                else {
                    document.getElementById('iw-loss-container').classList.remove('hidden');
                    document.getElementById('iw-continue-container').classList.remove('hidden');
                }
            }, 1000);
        }
        function claimInstant() {
            const email = document.getElementById('email-instant').value;
            if(!email.includes('@')) { alert("Bitte E-Mail eingeben"); return; }
            document.getElementById('iw-win-container').innerHTML = "<h3>Gespeichert!</h3>";
            document.getElementById('iw-continue-container').classList.remove('hidden');
        }
        function startStreakMode() {
            state.mode = 'streak'; 
            state.streak = 1;
            document.getElementById('score-val').innerText = "1";
            state.wonBottles = []; 
            state.wonBottles.push({ relX: (Math.random() - 0.5) * 40, relY: -10, rot: (Math.random() - 0.5) * 0.5 });
            showScreen('');
            bottle.reset(); 
            bucketObj.resetPos();
        }
        function submitRaffle() { 
            // SECURITY: Send final payload
            console.log("FINAL SUBMISSION:", SECURITY.getPayload());
            alert("Daten √ºbertragen!"); 
            location.reload(); 
        }
        
        function resize() {
            const container = document.getElementById('game-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const screenW = window.innerWidth;
            
            // DUAL BACKGROUND LOGIC
            isPC = screenW >= 768; 

            cvs.width = w;
            cvs.height = h;
            
            const heightRatio = 8000 / 4796; 

            if(isPC) {
                // PC
                IMG_SIZES.bottle.w = GAME_CONFIG.pc.bottleWidth;
                IMG_SIZES.bottle.h = IMG_SIZES.bottle.w * heightRatio; 
                IMG_SIZES.cap.w = GAME_CONFIG.pc.capSize;
                IMG_SIZES.cap.h = GAME_CONFIG.pc.capSize;
                CAP_START_Y = VH - GAME_CONFIG.pc.bottleBottom;
            } else {
                // Mobile
                IMG_SIZES.bottle.w = GAME_CONFIG.mobile.bottleWidth;
                IMG_SIZES.bottle.h = IMG_SIZES.bottle.w * heightRatio; 
                IMG_SIZES.cap.w = GAME_CONFIG.mobile.capSize;
                IMG_SIZES.cap.h = GAME_CONFIG.mobile.capSize;
                CAP_START_Y = VH - GAME_CONFIG.mobile.bottleBottom;
            }

            if(state.phase === 'idle') {
                bottle.y = CAP_START_Y;
            }

            scale = Math.min(w / VW, h / VH);
        }

        loadAssets();

    </script>
</body>
</html>