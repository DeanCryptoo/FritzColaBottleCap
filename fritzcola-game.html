<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>fritz-kola | ULTIMATE CHALLENGE</title>
    <link rel="icon" type="image/png" href="Logo.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bebas+Neue&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #050505;
            --white: #f1f1f1;
            --red: #c91a1a;
            --red-bright: #e82127;
            --neon-blue: #00f0ff;
            --gold: #FFD700;
            --gold-dark: #b8860b;
            --success: #00e676;
            --font-head: 'Bebas Neue', 'Anton', sans-serif;
            --font-body: 'Space Mono', monospace;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        html, body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--white);
            font-family: var(--font-body);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        /* === ADVANCED POST PROCESSING === */
        #noise-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        #vignette-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 30%, rgba(0,0,0,0.7) 70%, rgba(0,0,0,0.95) 100%);
        }

        #chromatic-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 12;
            opacity: 0;
            background: linear-gradient(90deg, rgba(255,0,0,0.1) 0%, rgba(0,255,0,0) 50%, rgba(0,0,255,0.1) 100%);
            mix-blend-mode: screen;
            transition: opacity 0.1s;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 480px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.9);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        /* === ENHANCED HEADER === */
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: max(30px, env(safe-area-inset-top));
            z-index: 50;
            pointer-events: none;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: translateY(-50px);
        }
        header.show-ui {
            opacity: 1;
            transform: translateY(0);
        }

        .logo-text {
            font-family: var(--font-head);
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 15px;
            text-shadow: 0 2px 20px rgba(0,0,0,0.9);
            background: linear-gradient(180deg, #fff 0%, #ccc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .red {
            color: var(--red-bright);
            -webkit-text-fill-color: var(--red-bright);
        }

        /* === ENHANCED PROGRESS BAR === */
        #progress-track {
            width: 220px;
            height: 14px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            transform: skewX(-12deg);
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        #progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--white) 0%, var(--neon-blue) 100%);
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.3s;
            box-shadow: 0 0 20px rgba(255,255,255,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
            position: relative;
        }

        #progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 100%);
        }

        #progress-fill.pulse {
            animation: progressPulse 0.5s ease-out;
        }

        @keyframes progressPulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
            100% { filter: brightness(1); }
        }

        #level-text {
            font-family: var(--font-head);
            font-size: 1rem;
            color: #888;
            margin-top: 8px;
            letter-spacing: 3px;
            text-shadow: 0 1px 3px #000;
        }

        /* === SCREENS === */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.92);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            padding-top: max(80px, calc(env(safe-area-inset-top) + 60px));
        }

        .screen.active {
            display: flex;
            opacity: 1;
        }

        /* Screen entrance animations */
        .screen.active .screen-content {
            animation: screenContentIn 0.6s 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 0;
        }

        @keyframes screenContentIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* === SCANNER === */
        #s-scan {
            background: #000;
            padding-top: 0;
            z-index: 60;
        }

        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6;
            transform: scaleX(-1);
        }

        .scan-frame {
            width: 260px;
            height: 260px;
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 24px;
            position: relative;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.3);
        }

        .scan-frame::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 24px;
            padding: 2px;
            background: linear-gradient(135deg, var(--red-bright), var(--red) 50%, var(--red-bright));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            animation: borderGlow 2s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .scan-corner {
            position: absolute;
            width: 50px;
            height: 50px;
            border-color: var(--red-bright);
            border-style: solid;
            border-width: 4px;
        }

        .tl { top: -2px; left: -2px; border-right: 0; border-bottom: 0; border-radius: 24px 0 0 0; }
        .tr { top: -2px; right: -2px; border-left: 0; border-bottom: 0; border-radius: 0 24px 0 0; }
        .bl { bottom: -2px; left: -2px; border-right: 0; border-top: 0; border-radius: 0 0 0 24px; }
        .br { bottom: -2px; right: -2px; border-left: 0; border-top: 0; border-radius: 0 0 24px 0; }

        .scan-line {
            position: absolute;
            width: 85%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--red-bright), transparent);
            box-shadow: 0 0 30px var(--red-bright), 0 0 60px var(--red);
            animation: scanAnim 2.5s infinite ease-in-out;
        }

        @keyframes scanAnim {
            0% { top: 10%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 90%; opacity: 0; }
        }

        .scan-status {
            position: relative;
            z-index: 10;
            font-family: var(--font-body);
            font-size: 0.85rem;
            color: var(--neon-blue);
            background: rgba(0,0,0,0.7);
            padding: 12px 24px;
            border-radius: 30px;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* === LOGO === */
        .start-logo {
            width: 180px;
            max-width: 55%;
            height: auto;
            margin-bottom: 30px;
            filter: drop-shadow(0 8px 25px rgba(0,0,0,0.7));
            animation: floatLogo 4s ease-in-out infinite;
        }

        @keyframes floatLogo {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(1deg); }
        }

        /* === TYPOGRAPHY === */
        h1 {
            font-family: var(--font-head);
            font-size: 4rem;
            margin: 0;
            line-height: 0.85;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 4px 30px rgba(0,0,0,0.8);
        }

        h1.glitch {
            position: relative;
            animation: glitchText 0.3s infinite;
        }

        @keyframes glitchText {
            0% { transform: translate(0); }
            20% { transform: translate(-3px, 3px); }
            40% { transform: translate(-3px, -3px); }
            60% { transform: translate(3px, 3px); }
            80% { transform: translate(3px, -3px); }
            100% { transform: translate(0); }
        }

        h2 {
            font-family: var(--font-head);
            font-size: 2.2rem;
            margin: 0 0 15px 0;
            color: var(--white);
            letter-spacing: 2px;
        }

        p {
            color: #aaa;
            margin: 20px 0 35px 0;
            max-width: 320px;
            line-height: 1.5;
            font-size: 0.95rem;
            font-weight: 400;
        }

        /* === ENHANCED BUTTONS === */
        .btn {
            background: var(--white);
            color: var(--bg);
            font-family: var(--font-head);
            font-size: 1.4rem;
            padding: 20px 0;
            width: 100%;
            max-width: 300px;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            margin: 10px 0;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            position: relative;
            pointer-events: auto;
            user-select: none;
            transition: transform 0.15s, box-shadow 0.15s;
            box-shadow: 5px 5px 0px var(--red), 0 5px 20px rgba(0,0,0,0.5);
            letter-spacing: 3px;
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px var(--red), 0 8px 30px rgba(0,0,0,0.6);
        }

        .btn:active {
            transform: translate(3px, 3px);
            box-shadow: 2px 2px 0px var(--red);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .btn-outline {
            background: transparent;
            color: var(--white);
            border: 2px solid rgba(255,255,255,0.25);
            box-shadow: none;
        }

        .btn-outline:hover {
            border-color: var(--white);
            background: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        .btn-outline:active {
            background: rgba(255,255,255,0.2);
        }

        .btn-gold {
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            box-shadow: 5px 5px 0px #8b6914, 0 5px 20px rgba(255, 215, 0, 0.3);
        }

        .btn-gold:hover {
            box-shadow: 7px 7px 0px #8b6914, 0 8px 30px rgba(255, 215, 0, 0.5);
        }

        .hidden {
            display: none !important;
        }

        /* === INPUTS === */
        input {
            border: 2px solid #333;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 16px;
            width: 100%;
            font-family: var(--font-body);
            text-align: center;
            margin-bottom: 12px;
            font-size: 1rem;
            outline: none;
            pointer-events: auto;
            text-transform: uppercase;
            border-radius: 8px;
            transition: border-color 0.3s, box-shadow 0.3s;
            letter-spacing: 1px;
        }

        input:focus {
            border-color: var(--red-bright);
            box-shadow: 0 0 20px rgba(232, 33, 39, 0.3);
        }

        /* === TUTORIAL === */
        #tutorial-overlay {
            position: absolute;
            bottom: 35%;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 15;
        }

        #tutorial-overlay.show {
            opacity: 1;
        }

        .hand {
            font-size: 5rem;
            display: block;
            animation: flickUp 1.8s infinite cubic-bezier(0.25, 1, 0.5, 1);
            filter: drop-shadow(0 8px 15px rgba(0,0,0,0.8));
        }

        .hint {
            font-family: var(--font-head);
            font-size: 1.4rem;
            text-transform: uppercase;
            text-shadow: 0 2px 6px #000;
            letter-spacing: 4px;
            display: block;
            margin-top: 10px;
        }

        @keyframes flickUp {
            0% { transform: translateY(40px) rotate(0deg) scale(0.8); opacity: 0; }
            15% { opacity: 1; }
            50% { transform: translateY(-60px) rotate(-8deg) scale(1.1); opacity: 1; }
            100% { transform: translateY(-100px) rotate(-15deg) scale(0.9); opacity: 0; }
        }

        /* === LOADING SCREEN === */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: var(--font-head);
            letter-spacing: 4px;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.8s;
        }

        #loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader-logo {
            margin-bottom: 40px;
            animation: loadPulse 1.5s ease-in-out infinite;
        }

        .loader-logo img {
            width: 120px;
            height: auto;
            display: block;
        }

        @keyframes loadPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        .loader-bar {
            width: 180px;
            height: 4px;
            background: #222;
            margin-top: 15px;
            position: relative;
            overflow: hidden;
            border-radius: 2px;
        }

        .loader-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 30%;
            background: linear-gradient(90deg, var(--red), var(--red-bright));
            border-radius: 2px;
            animation: loadAnim 1.2s infinite ease-in-out;
        }

        @keyframes loadAnim {
            0% { left: -30%; }
            100% { left: 100%; }
        }

        /* === WIN/LOSS EFFECTS === */
        .screen-flash-white {
            animation: flashWhite 0.5s ease-out;
        }

        @keyframes flashWhite {
            0% { background: rgba(255,255,255,0.9); }
            100% { background: rgba(0,0,0,0.92); }
        }

        .shake {
            animation: shake 0.4s ease-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px) rotate(-1deg); }
            40% { transform: translateX(10px) rotate(1deg); }
            60% { transform: translateX(-8px) rotate(-0.5deg); }
            80% { transform: translateX(8px) rotate(0.5deg); }
        }

        /* === SVG GRAPHICS === */
        .svg-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
        }

        .win-icon {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            animation: bounceIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes bounceIn {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* === RESPONSIVE === */
        @media screen and (max-height: 700px) {
            .screen { padding-top: 60px; }
            h1 { font-size: 3rem; }
            h2 { font-size: 1.6rem; }
            .start-logo { width: 140px; }
            .hand { font-size: 4rem; }
        }

        /* === SAFE AREA BOTTOM === */
        .screen {
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        /* === PARTICLE CONTAINER === */
        #particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        /* === FLOATING TEXT === */
        .floating-text {
            position: absolute;
            font-family: var(--font-head);
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            pointer-events: none;
            z-index: 25;
            text-shadow: 0 3px 10px rgba(0,0,0,0.8);
            animation: floatUp 1.5s ease-out forwards;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(0.5); }
            20% { transform: translateY(-20px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-100px) scale(1); }
        }

        /* === PROGRESS DOTS === */
        .progress-dots {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s;
        }

        .progress-dot.filled {
            background: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .progress-dot.gold {
            background: var(--gold);
            box-shadow: 0 0 10px var(--gold);
        }

        /* === NOTCH AREA === */
        .notch-spacer {
            height: max(30px, env(safe-area-inset-top));
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            z-index: 55;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader-logo">
            <img src="Logo.png" alt="Fritz Cola Logo">
        </div>
        <div style="font-size: 1.5rem;">FRITZ<span class="red">.</span></div>
        <div class="loader-bar"><div class="loader-fill"></div></div>
    </div>

    <!-- Post Processing Layers -->
    <div id="noise-layer"></div>
    <div id="vignette-layer"></div>
    <div id="chromatic-layer"></div>
    <div class="notch-spacer"></div>

    <div id="game-container">
        <!-- Header -->
        <header id="main-header">
            <div class="logo-text">FRITZ<span class="red">-</span>KOLA</div>
            <div id="progress-track"><div id="progress-fill"></div></div>
            <div id="level-text">STREAK <span id="streak-val">0</span>/10</div>
            <div class="progress-dots" id="progress-dots"></div>
        </header>

        <!-- Game Canvas -->
        <div id="game-layer">
            <canvas id="c"></canvas>
            <div id="tutorial-overlay">
                <span class="hand">üëÜ</span>
                <span class="hint">Schnippen</span>
            </div>
        </div>

        <!-- Particle Container -->
        <div id="particles-container"></div>

        <!-- UI Layer -->
        <div id="ui-layer">

            <!-- Scan Screen -->
            <div id="s-scan" class="screen">
                <video id="video-feed" autoplay playsinline muted></video>
                <div class="scan-frame">
                    <div class="scan-corner tl"></div>
                    <div class="scan-corner tr"></div>
                    <div class="scan-corner bl"></div>
                    <div class="scan-corner br"></div>
                    <div class="scan-line"></div>
                </div>
                <p class="scan-status" style="margin-top: 30px;">Code wird gescannt...</p>
            </div>

            <!-- Intro Screen -->
            <div id="s-intro" class="screen">
                <div class="screen-content">
                    <!-- PNG Logo -->
                    <img class="start-logo" src="Logo.png" alt="Fritz Cola Logo">

                    <h1>Deckel <span class="red">Ab</span></h1>
                    <p>Flasche scannen um zu spielen.<br>Schnipp den Deckel in den Eimer.</p>

                    <div id="token-status" style="margin-bottom: 25px; font-family: var(--font-body); color: var(--red-bright); font-size: 0.8rem; letter-spacing: 2px;">
                        <span style="opacity: 0.7;">Pr√ºfe Token...</span>
                    </div>

                    <button class="btn hidden" id="btn-start" ontouchstart="startGame()" onclick="startGame()">
                        Spiel Starten
                    </button>
                </div>
            </div>

            <!-- Instant Win Screen -->
            <div id="s-instant" class="screen">
                <div class="screen-content">
                    <div id="iw-icon-container"></div>
                    <h1 id="iw-title">Sauber!</h1>
                    <p id="iw-msg">Pr√ºfe Sofortgewinn...</p>

                    <div id="iw-win-container" class="hidden" style="width: 100%; max-width: 320px; min-height: 200px;">
                        <!-- SVG Trophy -->
                        <svg class="win-icon" viewBox="0 0 100 100">
                            <defs>
                                <linearGradient id="goldGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FFD700"/>
                                    <stop offset="50%" style="stop-color:#FFA500"/>
                                    <stop offset="100%" style="stop-color:#B8860B"/>
                                </linearGradient>
                            </defs>
                            <path d="M30 35 L30 75 L70 75 L70 35 Z" fill="url(#goldGrad)" stroke="#B8860B" stroke-width="2"/>
                            <path d="M25 35 Q50 20 75 35" fill="url(#goldGrad)" stroke="#B8860B" stroke-width="2"/>
                            <rect x="40" y="75" width="20" height="10" fill="url(#goldGrad)" stroke="#B8860B" stroke-width="2"/>
                            <text x="50" y="60" text-anchor="middle" fill="#fff" font-size="20" font-family="Bebas Neue">1</text>
                        </svg>

                        <h2 style="color: var(--gold);">Shirt Gewonnen!</h2>
                        <p>Gib deine E-Mail ein um den Gewinn zu sichern.</p>
                        <input type="email" id="email-instant" placeholder="deine@email.de">
                        <button class="btn btn-gold" ontouchstart="claimInstant()" onclick="claimInstant()">
                            Gewinn Sichern
                        </button>
                    </div>

                    <div id="iw-loss-container" class="hidden" style="width: 100%; max-width: 320px;">
                        <!-- SVG Sad Face -->
                        <svg class="svg-icon" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="40" fill="none" stroke="#666" stroke-width="3"/>
                            <circle cx="35" cy="40" r="5" fill="#666"/>
                            <circle cx="65" cy="40" r="5" fill="#666"/>
                            <path d="M30 65 Q50 55 70 65" stroke="#666" stroke-width="3" fill="none"/>
                        </svg>

                        <h2>Kein Sofortgewinn</h2>
                        <p>Aber du kannst noch gro√ü abr√§umen.</p>
                    </div>

                    <div id="iw-continue-container" class="hidden" style="width: 100%; max-width: 320px; margin-top: 40px; padding-top: 25px; border-top: 1px solid #333;">
                        <h3 style="margin:0 0 12px 0; font-family:var(--font-head); color:var(--white); letter-spacing: 2px;">
                            Hauptpreis Gewinnen?
                        </h3>
                        <p style="margin: 0 0 20px 0; color:#777; font-size: 0.85rem;">
                            Schaffst du 10 Treffer in Folge?
                        </p>
                        <button class="btn" ontouchstart="startStreakMode()" onclick="startStreakMode()">
                            Challenge Starten
                        </button>
                        <button class="btn btn-outline" style="margin-top:12px" ontouchstart="location.reload()" onclick="location.reload()">
                            Nein Danke
                        </button>
                    </div>
                </div>
            </div>

            <!-- Fail Screen -->
            <div id="s-fail" class="screen">
                <div class="screen-content">
                    <!-- SVG X -->
                    <svg class="svg-icon" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="40" fill="none" stroke="#666" stroke-width="3"/>
                        <line x1="30" y1="30" x2="70" y2="70" stroke="#666" stroke-width="4"/>
                        <line x1="70" y1="30" x2="30" y2="70" stroke="#666" stroke-width="4"/>
                    </svg>

                    <h1 class="glitch" style="color: #555;">Daneben</h1>
                    <p>Der Streak ist vorbei.<br>Versuch es noch einmal.</p>
                    <button class="btn" ontouchstart="location.reload()" onclick="location.reload()">
                        Neue Flasche Scannen
                    </button>
                </div>
            </div>

            <!-- Raffle Screen -->
            <div id="s-raffle" class="screen">
                <div class="screen-content">
                    <!-- SVG Star -->
                    <svg class="win-icon" viewBox="0 0 100 100" style="animation-delay: 0.2s;">
                        <defs>
                            <linearGradient id="starGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#FFD700"/>
                                <stop offset="100%" style="stop-color:#FF8C00"/>
                            </linearGradient>
                        </defs>
                        <polygon points="50,5 61,35 95,35 68,55 79,90 50,70 21,90 32,55 5,35 39,35" fill="url(#starGrad)" stroke="#B8860B" stroke-width="2"/>
                    </svg>

                    <h1 style="color: var(--gold); text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">Legend√§r!</h1>
                    <p>10 Treffer in Folge.<br>Du bist im Lostopf.</p>

                    <div style="width: 100%; max-width: 320px;">
                        <input type="email" id="email-raffle" placeholder="deine@email.de">
                        <button class="btn btn-gold" ontouchstart="submitRaffle()" onclick="submitRaffle()">
                            Teilnehmen
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === AUDIO ENGINE (Enhanced) ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;

            if (type === 'pop') {
                // More satisfying pop sound
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(280, now);
                osc.frequency.exponentialRampToValueAtTime(60, now + 0.12);
                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(now); osc.stop(now + 0.12);

                // Add click layer
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(800, now);
                gain2.gain.setValueAtTime(0.1, now);
                gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc2.start(now); osc2.stop(now + 0.03);

            } else if (type === 'swoosh') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.25);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.25);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(now); osc.stop(now + 0.25);

            } else if (type === 'clink') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.setValueAtTime(1200, now + 0.02);
                gain.gain.setValueAtTime(0.06, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(now); osc.stop(now + 0.08);

            } else if (type === 'win') {
                // Victory chord
                [440, 554, 659].forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, now);
                    gain.gain.setValueAtTime(0.08, now + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5 + i * 0.08);
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.start(now + i * 0.08); osc.stop(now + 0.5 + i * 0.08);
                });

            } else if (type === 'lose') {
                // Sad descending tone
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        // === CANVAS SETUP ===
        const cvs = document.getElementById('c');
        const ctx = cvs.getContext('2d');
        const VH = 1000;
        const VW = 600;
        let scale = 1;
        let globalTime = 0;
        let isPC = false;

        // Parallax State
        let parallax = { x: 0, y: 0 };
        window.addEventListener('mousemove', e => {
            parallax.x = (e.clientX / window.innerWidth - 0.5) * 20;
            parallax.y = (e.clientY / window.innerHeight - 0.5) * 20;
        });

        // === ASSET LOADER ===
        const images = {};
        const imageSources = {
            bottle: 'Bottle.png',
            cap: 'BottleCap.png',
            bucket: 'icebucket.png',
            bgPhone: 'backgroundPhone.jpeg',
            logo: 'Logo.png'
        };

        const GAME_CONFIG = {
            pc: { bottleWidth: 240, bottleBottom: 150, capSize: 60, capYOffset: 12 },
            mobile: { bottleWidth: 220, bottleBottom: 150, capSize: 60, capYOffset: 12 },
            visuals: { bgOverlayOpacity: 0.5 }
        };

        const SECURITY = {
            startTime: 0, startPos: {x:0, y:0}, shots: [],
            recordShot: function(vecX, vecY) { this.shots.push({ ts: Date.now(), dx: vecX, dy: vecY, valid: true }); },
            getPayload: function() { return JSON.stringify({ token: state.token, sessionData: this.shots, finalStreak: state.streak }); }
        };

        const GRAVITY = 0.85;
        const POWER_X = 0.11;
        const POWER_Y = 0.17;
        const SCALE_NEAR = 3.5;
        const SCALE_FAR = 1.1;
        let CAP_START_Y = VH - 200;
        let CAP_OFFSET = 12;

        let IMG_SIZES = { bottle: { w: 100, h: 100 }, cap: { w: 30, h: 30 }, bucket: { w: 240, h: 240 } };

        const state = {
            token: null, phase: 'idle', mode: 'warmup', streak: 0,
            cameraY: 0, cameraShake: 0, screenFlash: 0, timeScale: 1.0,
            freezeFrame: 0, bgEnergy: 0, wonBottles: [], shockwaves: [],
            floatTexts: [], bgParticles: [], bottleRecoil: 0, introProgress: 0,
            gameActive: false,
            trail: []
        };

        function easeOutBack(x) {
            const c1 = 1.70158; const c3 = c1 + 1; return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
        }

        // === BOTTLE OBJECT ===
        const bottle = {
            x: 0, y: 0, w: 22, h: 8, z: SCALE_NEAR,
            vx: 0, vy: 0, rot: 0, vRot: 0,
            bodyX: 0, oldBodyX: 0, animState: 'idle', animTimer: 0,

            startSwap: function() { this.animState = 'swapping_out'; this.oldBodyX = VW / 2; this.animTimer = 0; },

            reset: function(animate = false) {
                this.y = CAP_START_Y; this.z = SCALE_NEAR;
                this.vx = 0; this.vy = 0; this.rot = 0; this.vRot = 0;
                state.trail = [];

                if(animate) { this.startSwap(); }
                else { this.bodyX = VW / 2; this.x = VW / 2; this.animState = 'idle'; state.phase = 'idle'; }

                state.cameraY = 0; state.timeScale = 1.0; state.bottleRecoil = 0;
            },

            updateAnimation: function() {
                if (this.animState === 'swapping_out') {
                    this.oldBodyX += 40;
                    if (this.oldBodyX > VW + 200) { this.animState = 'swapping_in'; this.animTimer = 0; this.bodyX = -200; }
                }
                else if (this.animState === 'swapping_in') {
                    this.animTimer += 0.03; if(this.animTimer > 1) this.animTimer = 1;
                    let t = easeOutBack(this.animTimer);
                    let startX = -200; let targetX = VW / 2;
                    this.bodyX = startX + (targetX - startX) * t;
                    let tilt = (1 - t) * -0.5; this.rot = tilt; this.x = this.bodyX;

                    if(this.animTimer >= 1) { this.animState = 'idle'; state.phase = 'idle'; this.rot = 0; }
                }
                else if (state.phase !== 'flying') {
                    this.bodyX = VW / 2;
                    if(state.phase === 'idle' || state.phase === 'aiming') { this.x = this.bodyX; }
                }
            }
        };

        // === BUCKET OBJECT ===
        const bucketObj = {
            x: VW / 2, y: 550, w: IMG_SIZES.bucket.w, h: IMG_SIZES.bucket.h, scale: SCALE_FAR,
            scaleAnim: 1.0, squash: {x:1, y:1}, angle: 0,
            init: function() { },
            resetPos: function() { this.x = VW/2; this.y = 550; this.angle = 0; },
            update: function() {
                this.squash.x += (1 - this.squash.x) * 0.15;
                this.squash.y += (1 - this.squash.y) * 0.15;

                if(state.mode === 'streak' && state.streak >= 3) {
                    let speed = 0.0005 + (state.streak * 0.00025);
                    let range = 80 + (state.streak * 6);
                    this.angle += speed * 16.6 * state.timeScale;
                    this.x = (VW/2) + Math.sin(this.angle) * range;
                }
            }
        };
        bucketObj.init();

        // === PARTICLE SYSTEM ===
        const particles = [];

        function spawnParticles(x, y, type, customColor) {
            let count = type === 'confetti' ? 50 : 25;
            if(type === 'gas') count = 20;

            for(let i=0; i<count; i++) {
                let color = '#fff';
                let size = Math.random() * 10 + 5;

                if(type === 'confetti') {
                    if(customColor) color = customColor;
                    else {
                        const cols = ['#fff', '#c91a1a', '#00f0ff', '#FFD700', '#00e676'];
                        color = cols[Math.floor(Math.random()*cols.length)];
                    }
                } else if (type === 'spark') color = '#FFD700';
                else if (type === 'gas') { color = 'rgba(200, 200, 200, 0.5)'; size = Math.random() * 20 + 8; }
                else if (type === 'bubble') {
                    color = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`;
                    size = Math.random() * 15 + 5;
                }

                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5) * (type==='confetti'?30:18),
                    vy: (Math.random()-0.5) * (type==='confetti'?30:18) + (type==='gas'?-5:0),
                    life: 1.0, type: type, color: color, size: size,
                    rot: Math.random() * Math.PI, vRot: (Math.random()-0.5) * 0.6
                });
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.globalAlpha = p.life;

                if(p.type === 'splash') {
                    let rad = ctx.createRadialGradient(0,0,0, 0,0,15);
                    rad.addColorStop(0, 'rgba(0, 230, 118, 0.8)');
                    rad.addColorStop(1, 'rgba(0, 230, 118, 0)');
                    ctx.fillStyle = rad;
                    ctx.beginPath();
                    ctx.arc(0,0, 15, 0, Math.PI*2);
                    ctx.fill();
                } else if (p.type === 'confetti') {
                    ctx.fillStyle = p.color;
                    ctx.rotate(p.rot);
                    let scaleY = Math.cos(p.rot * 3);
                    ctx.scale(1, scaleY);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                } else if (p.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(0, -10); ctx.lineTo(2, 0); ctx.lineTo(0, 10); ctx.lineTo(-2, 0);
                    ctx.fill();
                } else if (p.type === 'gas') {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(0,0, p.size, 0, Math.PI*2);
                    ctx.fill();
                } else if (p.type === 'bubble') {
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0,0, p.size, 0, Math.PI*2);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0,0, 5, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // === FLOATING TEXT ===
        function spawnFloatingText(text, x, y, color = '#fff') {
            state.floatTexts.push({ text: text, x: x, y: y, life: 1.0, vy: -2, color: color });
        }

        function drawFloatingTexts() {
            ctx.save();
            ctx.textAlign = 'center';
            state.floatTexts.forEach(t => {
                ctx.font = "bold 55px 'Bebas Neue', 'Anton', sans-serif";
                ctx.fillStyle = t.color;
                ctx.globalAlpha = t.life;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5;
                ctx.strokeText(t.text, t.x, t.y);
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.restore();
        }

        // === SHOCKWAVES ===
        function spawnShockwave(x, y, color) { state.shockwaves.push({ x: x, y: y, r: 10, maxR: 800, alpha: 0.8, color: color }); }

        function updateEffects() {
            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx * state.timeScale;
                p.y += p.vy * state.timeScale;
                p.life -= 0.025 * state.timeScale;

                if(p.type === 'splash') p.vy += 0.5 * state.timeScale;
                else if (p.type === 'confetti') { p.vy += 0.5 * state.timeScale; p.rot += p.vRot * state.timeScale; }
                else if (p.type === 'gas') { p.size *= 1.05; p.life -= 0.015; }
                else if (p.type === 'bubble') { p.vy -= 0.3 * state.timeScale; p.size *= 1.02; }

                if(p.life <= 0) particles.splice(i, 1);
            }

            // Shockwaves
            for(let i=state.shockwaves.length-1; i>=0; i--) {
                let s = state.shockwaves[i];
                s.r += 45;
                s.alpha -= 0.035;
                if(s.alpha <= 0) state.shockwaves.splice(i, 1);
            }

            // Floating texts
            for(let i=state.floatTexts.length-1; i>=0; i--) {
                let t = state.floatTexts[i];
                t.y += t.vy * state.timeScale;
                t.life -= 0.018 * state.timeScale;
                if(t.life <= 0) state.floatTexts.splice(i, 1);
            }

            // Screen flash decay
            if(state.screenFlash > 0) state.screenFlash -= 0.08;

            // Bottle recoil decay
            state.bottleRecoil *= 0.8;

            // Intro progress
            if(state.gameActive && state.introProgress < 1) {
                state.introProgress += 0.02;
                if(state.introProgress > 1) state.introProgress = 1;
            }
        }

        // === HAPTIC FEEDBACK ===
        function triggerHaptic(type) {
            if (!navigator.vibrate) return;
            if (type === 'tension') navigator.vibrate(5);
            if (type === 'impact') navigator.vibrate(30);
            if (type === 'success') navigator.vibrate([30, 40, 30, 40, 80]);
            if (type === 'fail') navigator.vibrate([50, 30, 50]);
        }

        // === CHROMATIC ABERRATION ===
        function triggerChromatic() {
            const layer = document.getElementById('chromatic-layer');
            layer.style.opacity = '1';
            setTimeout(() => { layer.style.opacity = '0'; }, 150);
        }

        // === SCREEN SHAKE ===
        function triggerShake() {
            const container = document.getElementById('game-container');
            container.classList.add('shake');
            setTimeout(() => { container.classList.remove('shake'); }, 400);
        }

        // === PROGRESS DOTS ===
        function updateProgressDots() {
            const dotsContainer = document.getElementById('progress-dots');
            dotsContainer.innerHTML = '';

            for(let i = 0; i < 10; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';

                if(i < state.streak) {
                    dot.classList.add('filled');
                    if(i >= 7) dot.classList.add('gold');
                }

                dotsContainer.appendChild(dot);
            }
        }

        // === ASSET LOADING ===
        function loadAssets() {
            let loaded = 0;
            const keys = Object.keys(imageSources);
            const total = keys.length;

            if(total === 0) { init(); return; }

            keys.forEach(key => {
                const img = new Image();
                img.src = imageSources[key];
                img.onload = () => {
                    loaded++;
                    images[key] = img;
                    if(loaded === total) {
                        document.getElementById('loading-screen').classList.add('hidden');
                        setTimeout(() => { init(); }, 600);
                    }
                };
                img.onerror = () => {
                    loaded++;
                    if(loaded === total) init();
                };
            });
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);

            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            if(token) state.token = token;
            else state.token = "demo-" + Date.now();

            bottle.reset();
            updateProgressDots();
            loop();

            // Start camera scan
            startCameraScan();
        }

        // === CAMERA SCAN ===
        async function startCameraScan() {
            showScreen('s-scan');
            const video = document.getElementById('video-feed');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment" }
                });
                video.srcObject = stream;

                // Simulate scan delay
                setTimeout(() => {
                    stream.getTracks().forEach(track => track.stop());
                    checkTokenAndShowIntro();
                }, 2500);
            } catch (err) {
                console.log("Camera access denied or failed", err);
                setTimeout(() => checkTokenAndShowIntro(), 1200);
            }
        }

        function checkTokenAndShowIntro() {
            showScreen('s-intro');

            const statusEl = document.getElementById('token-status');
            if(state.token.startsWith('demo')) {
                statusEl.innerHTML = "<span style='opacity: 0.6;'>DEMO MODUS</span>";
            } else {
                statusEl.innerHTML = "‚úì TOKEN AKTIV";
            }

            document.getElementById('btn-start').classList.remove('hidden');
        }

        // === SHADOW DRAWING ===
        function drawShadow(x, scaleVal) {
             ctx.save();
             ctx.translate(x, CAP_START_Y + 110);
             ctx.scale(1, 0.3);
             ctx.beginPath();
             ctx.arc(0, 0, 45 * scaleVal, 0, Math.PI*2);
             ctx.fillStyle = 'rgba(0,0,0,0.6)';
             ctx.filter = 'blur(8px)';
             ctx.fill();
             ctx.restore();
        }

        // === BACKGROUND ===
        function drawBackground() {
            let px = parallax.x;
            let py = parallax.y;

            if(images.bgPhone && images.bgPhone.complete) {
                let bgImg = images.bgPhone;
                let bgRatio = bgImg.width / bgImg.height;
                let cvsRatio = cvs.width / cvs.height;
                ctx.save();
                ctx.translate(px, py);
                ctx.scale(1.08, 1.08);
                ctx.filter = 'blur(8px) brightness(0.5)';
                if (cvsRatio > bgRatio) {
                    let newH = cvs.width / bgRatio;
                    ctx.drawImage(bgImg, 0, (cvs.height - newH)/2, cvs.width, newH);
                } else {
                    let newW = cvs.height * bgRatio;
                    ctx.drawImage(bgImg, (cvs.width - newW)/2, 0, newW, cvs.height);
                }
                ctx.restore();
            } else {
                // Gradient background fallback
                let grad = ctx.createLinearGradient(0, 0, 0, cvs.height);
                grad.addColorStop(0, '#0a0a0a');
                grad.addColorStop(0.5, '#111111');
                grad.addColorStop(1, '#050505');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,cvs.width, cvs.height);
            }

            // Ambient particles (bubbles)
            if (Math.random() < 0.1) {
                particles.push({
                    x: Math.random() * cvs.width,
                    y: cvs.height + 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 3 - 1,
                    life: 1.0,
                    type: 'bubble',
                    color: 'rgba(255, 255, 255, 0.15)',
                    size: Math.random() * 8 + 3,
                    rot: 0,
                    vRot: 0
                });
            }

            // Lighting Engine
            let cx = cvs.width/2 + px;
            let cy = cvs.height/2 + py;

            let color = '255, 255, 255';
            let opacity = 0.08;

            if(state.streak >= 4) { color = '201, 26, 26'; opacity = 0.15; }
            if(state.streak >= 7) { color = '0, 240, 255'; opacity = 0.15; }
            if(state.streak >= 9) { color = '255, 215, 0'; opacity = 0.2; }

            let breath = 1 + Math.sin(globalTime * 2) * 0.05;

            let grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cvs.height * 0.8);
            grad.addColorStop(0, `rgba(${color}, ${opacity * breath})`);
            grad.addColorStop(1, 'rgba(0,0,0,0.85)');

            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,cvs.width, cvs.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        // === MAIN LOOP ===
        function loop() {
            globalTime += 0.05;
            if(state.freezeFrame > 0) { state.freezeFrame--; requestAnimationFrame(loop); return; }
            state.bgEnergy *= 0.95;

            drawBackground();

            if(state.gameActive) {
                let easedIntro = easeOutBack(state.introProgress);
                let bucketOffsetY = (1 - easedIntro) * -1000;
                let bottleOffsetY = (1 - easedIntro) * 1000;

                ctx.save();
                let offsetX = (cvs.width - (VW * scale)) / 2;
                ctx.translate(offsetX, 0);
                ctx.scale(scale, scale);

                // Draw shockwaves
                state.shockwaves.forEach(s => {
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 35;
                    ctx.globalAlpha = s.alpha;
                    ctx.stroke();
                });
                ctx.restore();

                ctx.save();
                ctx.translate(offsetX, 0);
                ctx.scale(scale, scale);

                let shakeX = (Math.random()-0.5) * state.cameraShake;
                let shakeY = (Math.random()-0.5) * state.cameraShake;
                state.cameraShake *= 0.85;
                ctx.translate(shakeX, state.cameraY + shakeY);

                bucketObj.update();
                let bScale = bucketObj.scale;
                ctx.save();
                ctx.translate(bucketObj.x, bucketObj.y + bucketOffsetY);
                ctx.scale(bScale * bucketObj.squash.x, bScale * bucketObj.squash.y);
                drawBucketImage();
                drawStoredBottles();
                ctx.restore();

                bottle.updateAnimation();

                // Draw old bottle
                if(bottle.animState === 'swapping_out') {
                    drawShadow(bottle.oldBodyX, 1);
                    ctx.save();
                    ctx.translate(bottle.oldBodyX, CAP_START_Y + bottleOffsetY);
                    ctx.scale(SCALE_NEAR, SCALE_NEAR);
                    drawStationaryBottle();
                    ctx.restore();
                }

                // Draw current bottle
                if(bottle.animState === 'swapping_in' || bottle.animState === 'idle') {
                    drawShadow(bottle.bodyX, 1);
                    ctx.save();
                    ctx.translate(bottle.bodyX, CAP_START_Y + state.bottleRecoil + bottleOffsetY);
                    ctx.scale(SCALE_NEAR, SCALE_NEAR);
                    if(bottle.animState === 'swapping_in') { ctx.rotate(bottle.rot); }
                    drawStationaryBottle();
                    ctx.restore();
                }

                // Calculate depth during flight
                if(state.phase === 'flying') {
                    let distTotal = (VH - 150) - bucketObj.y;
                    let currentDist = bottle.y - bucketObj.y;
                    let progress = Math.max(0, Math.min(1, currentDist / distTotal));
                    bottle.z = bucketObj.scale + (progress * (SCALE_NEAR - bucketObj.scale));
                }

                // Cap Drawing & Trails
                if(bottle.animState !== 'swapping_out' && state.phase !== 'in_bucket' && state.phase !== 'miss_anim_done') {
                    ctx.save();
                    let capAnimY = (state.phase === 'idle' || state.phase === 'aiming') ? bottleOffsetY : 0;

                    let totalY = bottle.y + capAnimY + CAP_OFFSET;

                    // Aim tension jitter
                    let jitterX = 0;
                    let jitterY = 0;
                    if(state.phase === 'aiming') {
                        jitterX = (Math.random()-0.5) * 3;
                        jitterY = (Math.random()-0.5) * 3;
                    }

                    // Trail rendering
                    if(state.phase === 'flying' && state.trail.length > 1) {
                        ctx.save();
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        for(let i=0; i < state.trail.length - 1; i++) {
                            let p1 = state.trail[i];
                            let p2 = state.trail[i+1];

                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y + capAnimY + CAP_OFFSET);
                            ctx.lineTo(p2.x, p2.y + capAnimY + CAP_OFFSET);

                            let progress = i / state.trail.length;
                            let alpha = progress * 0.7;
                            let width = progress * 30 * bottle.z;

                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.lineWidth = width;
                            ctx.stroke();
                        }
                        ctx.restore();
                    }

                    if(bottle.animState === 'swapping_in') {
                        ctx.translate(bottle.x + jitterX, totalY + jitterY);
                        ctx.rotate(bottle.rot);
                        ctx.scale(bottle.z, bottle.z);
                    } else {
                        ctx.translate(bottle.x + jitterX, totalY + jitterY);
                        ctx.scale(bottle.z, bottle.z);
                        ctx.rotate(bottle.rot);
                    }

                    drawCapGraphic();
                    ctx.restore();
                }

                updatePhysics();
                updateEffects();
                drawParticles();
                drawFloatingTexts();

                ctx.restore();
            }

            // Screen flash overlay
            if(state.screenFlash > 0.05) {
                ctx.fillStyle = `rgba(255,255,255,${state.screenFlash})`;
                ctx.fillRect(0,0,cvs.width, cvs.height);
            }

            requestAnimationFrame(loop);
        }

        // === PHYSICS ===
        function updatePhysics() {
            if(state.phase !== 'flying') return;

            // Record trail
            if(globalTime % 0.1 < 0.05) state.trail.push({x: bottle.x, y: bottle.y});

            state.timeScale = 1.0;

            bottle.vy += GRAVITY * state.timeScale;
            bottle.x += bottle.vx * state.timeScale;
            bottle.y += bottle.vy * state.timeScale;
            bottle.rot += bottle.vRot * state.timeScale;

            // Out of bounds
            if(bottle.y > VH + 200 || bottle.x < -100 || bottle.x > VW + 100) handleMiss();

            let targetY = bucketObj.y - (bucketObj.h * bucketObj.scale)/2;
            let rimW = bucketObj.w * bucketObj.scale;

            // Collision detection
            if(Math.abs(bottle.y - targetY) < 50 && bottle.vy > 0) {
                // Direct hit
                if(Math.abs(bottle.x - bucketObj.x) < rimW/2 + 15) {
                    handleScore();
                }
                // Rim hit (bounce)
                else if (Math.abs(bottle.x - bucketObj.x) < rimW/2 + 35) {
                    bottle.vx *= -0.6;
                    bottle.vRot += (Math.random()-0.5) * 5;
                    state.cameraShake = 35;
                    state.freezeFrame = 5;
                    spawnParticles(bottle.x, bottle.y, 'spark');
                    triggerHaptic('impact');
                    playSound('clink');
                }
            }
        }

        // === SCORE HANDLER ===
        function handleScore() {
            playSound('win');
            state.phase = 'in_bucket';
            bottle.vx = 0;
            bottle.vy = 0;
            state.bgEnergy = 180;
            state.cameraShake = 50;
            state.screenFlash = 0.5;
            state.freezeFrame = 10;

            bottle.y += 20;

            // Bucket squash
            bucketObj.squash = {x: 1.35, y: 0.65};

            triggerHaptic('success');
            spawnParticles(bucketObj.x, bucketObj.y - 50, 'splash');

            // Wave color based on streak
            let waveColor = '#fff';
            if(state.streak >= 4 && state.streak < 7) waveColor = '#c91a1a';
            else if(state.streak >= 7 && state.streak < 9) waveColor = '#00ccff';
            else if(state.streak >= 9) waveColor = '#FFD700';

            spawnParticles(bucketObj.x, bucketObj.y - 120, 'confetti', waveColor);
            spawnShockwave(bucketObj.x, bucketObj.y, waveColor);

            if(state.mode === 'streak') {
                state.streak++;
                document.getElementById('streak-val').innerText = state.streak;

                let percent = (state.streak / 10) * 100;
                let fill = document.getElementById('progress-fill');
                fill.style.width = percent + "%";

                // Progress bar pulse
                fill.classList.add('pulse');
                setTimeout(() => fill.classList.remove('pulse'), 500);

                if(state.streak >= 7) fill.style.background = 'linear-gradient(90deg, var(--neon-blue), #fff)';
                if(state.streak >= 9) fill.style.background = 'linear-gradient(90deg, var(--gold), #fff)';

                updateProgressDots();

                // Messages
                let msgs = ["Sauber!", "Glatt!", "Rein!", "Perfekt!"];
                let msg = msgs[Math.floor(Math.random()*msgs.length)];

                let msgColor = '#fff';
                if(state.streak % 5 === 0) {
                    msg = "LEGEND√ÑR!";
                    msgColor = '#FFD700';
                }
                else if(state.streak >= 7) msgColor = '#00f0ff';

                spawnFloatingText(msg, bucketObj.x, bucketObj.y - 180, msgColor);
            } else {
                state.streak = 1;
                spawnFloatingText("Treffer!", bucketObj.x, bucketObj.y - 150, '#00e676');
            }

            console.log("SENDING SECURE SCORE:", SECURITY.getPayload());

            setTimeout(() => {
                let baseHeight = -10;
                let stackHeight = state.wonBottles.length * 18;
                let yOffset = -70;

                state.wonBottles.push({
                    relX: (Math.random() - 0.5) * 80,
                    relY: baseHeight - stackHeight + yOffset + (Math.random() * 10),
                    rot: (Math.random() - 0.5) * 2.0
                });

                if(state.mode === 'warmup') {
                    showInstantWinCheck();
                }
                else if (state.mode === 'streak') {
                    if(state.streak >= 10) showScreen('s-raffle');
                    else {
                        bottle.reset(true);
                    }
                }
            }, 700);
        }

        // === MISS HANDLER ===
        function handleMiss() {
            playSound('lose');
            triggerShake();
            triggerHaptic('fail');
            triggerChromatic();

            state.phase = 'miss';
            setTimeout(() => {
                if(state.mode === 'warmup') bottle.reset(true);
                else showScreen('s-fail');
            }, 600);
        }

        // === DRAWING FUNCTIONS ===
        function drawBucketImage() {
            if(images.bucket) {
                let w = IMG_SIZES.bucket.w;
                let h = IMG_SIZES.bucket.h;
                ctx.drawImage(images.bucket, -w/2, -h/2, w, h);
            } else {
                // Fallback bucket
                ctx.save();
                let w = IMG_SIZES.bucket.w;
                let h = IMG_SIZES.bucket.h;

                // Bucket body
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.moveTo(-w/2 + 20, -h/2);
                ctx.lineTo(-w/2 + 10, h/2);
                ctx.lineTo(w/2 - 10, h/2);
                ctx.lineTo(w/2 - 20, -h/2);
                ctx.closePath();
                ctx.fill();

                // Bucket rim
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(-w/2 + 20, -h/2);
                ctx.lineTo(w/2 - 20, -h/2);
                ctx.stroke();

                // Ice effect
                ctx.fillStyle = 'rgba(0, 240, 255, 0.1)';
                ctx.fillRect(-w/2 + 15, -h/2 + 10, w - 30, h/2 - 10);

                ctx.restore();
            }
        }

        function drawStoredBottles() {
            state.wonBottles.forEach(b => {
                ctx.save();
                ctx.translate(b.relX, b.relY);
                ctx.rotate(b.rot);
                ctx.scale(1.2, 1.2);
                drawCapGraphic();
                ctx.restore();
            });
        }

        function drawStationaryBottle() {
            if(images.bottle) {
                let w = IMG_SIZES.bottle.w;
                let h = IMG_SIZES.bottle.h;
                ctx.drawImage(images.bottle, -w/2, -10, w, h);
            } else {
                // Fallback bottle
                ctx.save();
                let w = IMG_SIZES.bottle.w;
                let h = IMG_SIZES.bottle.h;

                // Bottle body
                let grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
                grad.addColorStop(0, '#333');
                grad.addColorStop(0.3, '#666');
                grad.addColorStop(0.5, '#888');
                grad.addColorStop(0.7, '#666');
                grad.addColorStop(1, '#333');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.roundRect(-w/2, -10, w, h + 10, 5);
                ctx.fill();

                // Label
                ctx.fillStyle = '#c91a1a';
                ctx.fillRect(-w/4, h/4, w/2, h/3);

                ctx.restore();
            }
        }

        function drawCapGraphic() {
            if(images.cap) {
                let w = IMG_SIZES.cap.w;
                let h = IMG_SIZES.cap.h;
                ctx.drawImage(images.cap, -w/2, -h/2, w, h);
            } else {
                // Fallback cap
                ctx.save();
                let w = IMG_SIZES.cap.w;
                let h = IMG_SIZES.cap.h;

                // Cap body
                let grad = ctx.createLinearGradient(0, -h/2, 0, h/2);
                grad.addColorStop(0, '#eee');
                grad.addColorStop(0.5, '#fff');
                grad.addColorStop(1, '#ccc');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cap ring
                ctx.strokeStyle = '#c91a1a';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(0, 2, w/2 - 2, h/2 - 2, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        // === INPUT HANDLING ===
        const input = { active: false, startX: 0, startY: 0, currX: 0, currY: 0, cooldown: false };

        function handleInputStart(x, y) {
            if(input.cooldown) return;
            if(state.phase !== 'idle') return;
            playSound('pop');
            triggerHaptic('tension');

            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            let relativeX = x - rect.left;
            let relativeY = y - rect.top;
            let offsetX = (cvs.width - (VW * scale)) / 2;
            let virtX = (relativeX - offsetX) / scale;
            let virtY = relativeY / scale;

            if(virtY > VH * 0.4) {
                input.active = true;
                input.startX = virtX;
                input.startY = virtY;
                input.currX = virtX;
                input.currY = virtY;
                state.phase = 'aiming';
                document.getElementById('tutorial-overlay').classList.remove('show');
                SECURITY.startTime = Date.now();
                SECURITY.startPos = {x: virtX, y: virtY};
            }
        }

        function handleInputMove(x, y) {
            if(!input.active) return;
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            let relativeX = x - rect.left;
            let relativeY = y - rect.top;
            let offsetX = (cvs.width - (VW * scale)) / 2;
            input.currX = (relativeX - offsetX) / scale;
            input.currY = relativeY / scale;
        }

        function handleInputEnd() {
            if(!input.active) return;
            input.active = false;
            let dx = input.currX - input.startX;
            let dy = input.currY - input.startY;

            if(dy < -30) {
                playSound('swoosh');
                state.phase = 'flying';
                bottle.vx = dx * POWER_X;
                bottle.vy = dy * POWER_Y;
                bottle.vRot = (Math.random() - 0.5) * 0.8;
                spawnParticles(VW/2, CAP_START_Y, 'gas');
                state.bottleRecoil = 30;
                SECURITY.recordShot(bottle.vx, bottle.vy);
            } else {
                state.phase = 'idle';
            }
        }

        // Event listeners
        const gameContainer = document.getElementById('game-container');
        gameContainer.addEventListener('touchstart', e => {
             if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
                 e.preventDefault();
                 handleInputStart(e.touches[0].clientX, e.touches[0].clientY);
             }
        }, {passive:false});

        gameContainer.addEventListener('touchmove', e => {
             if(input.active) {
                 e.preventDefault();
                 handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
             }
        }, {passive:false});

        gameContainer.addEventListener('touchend', e => {
             if(input.active) {
                 e.preventDefault();
                 handleInputEnd();
             }
        }, {passive:false});

        window.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleInputEnd);

        // === SCREEN MANAGEMENT ===
        const header = document.getElementById('main-header');

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if(id) {
                document.getElementById(id).classList.add('active');
                header.classList.remove('show-ui');
            }
            else {
                header.classList.add('show-ui');
            }
        }

        function startGame() {
            playSound('pop');
            showScreen('');
            document.getElementById('tutorial-overlay').classList.add('show');
            state.gameActive = true;
            input.cooldown = true;
            setTimeout(() => { input.cooldown = false; }, 600);
        }

        // === INSTANT WIN ===
        function showInstantWinCheck() {
            showScreen('s-instant');
            const isWinner = Math.random() < 0.3;

            setTimeout(() => {
                document.getElementById('iw-msg').classList.add('hidden');

                if(isWinner) {
                    document.getElementById('iw-win-container').classList.remove('hidden');
                } else {
                    document.getElementById('iw-loss-container').classList.remove('hidden');
                    document.getElementById('iw-continue-container').classList.remove('hidden');
                }
            }, 1200);
        }

        function claimInstant() {
            playSound('pop');
            const email = document.getElementById('email-instant').value;
            if(!email.includes('@')) {
                alert("Bitte E-Mail eingeben");
                return;
            }

            document.getElementById('iw-win-container').innerHTML = `
                <svg class="win-icon" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#00e676" stroke-width="3"/>
                    <path d="M30 50 L45 65 L70 35" stroke="#00e676" stroke-width="6" fill="none" stroke-linecap="round"/>
                </svg>
                <h2 style="color: var(--success);">Gespeichert!</h2>
                <p>Wir melden uns bei dir.</p>
            `;

            setTimeout(() => {
                document.getElementById('iw-continue-container').classList.remove('hidden');
            }, 500);
        }

        function startStreakMode() {
            playSound('swoosh');
            state.mode = 'streak';
            if(state.streak === 0) state.streak = 1;

            document.getElementById('streak-val').innerText = state.streak;
            let percent = (state.streak / 10) * 100;
            document.getElementById('progress-fill').style.width = percent + "%";

            state.wonBottles = [];
            state.wonBottles.push({ relX: (Math.random() - 0.5) * 40, relY: -70, rot: (Math.random() - 0.5) * 0.5 });

            updateProgressDots();
            showScreen('');
            bottle.reset(true);
            bucketObj.resetPos();
        }

        function submitRaffle() {
            const email = document.getElementById('email-raffle').value;
            if(!email.includes('@')) {
                alert("Bitte E-Mail eingeben");
                return;
            }

            console.log("FINAL SUBMISSION:", SECURITY.getPayload());

            // Success animation
            const screen = document.getElementById('s-raffle');
            screen.classList.add('screen-flash-white');

            setTimeout(() => {
                alert("Daten √ºbertragen! Viel Gl√ºck!");
                location.reload();
            }, 800);
        }

        // === RESIZE ===
        function resize() {
            const container = document.getElementById('game-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const screenW = window.innerWidth;

            isPC = screenW >= 768;
            cvs.width = w;
            cvs.height = h;
            const heightRatio = 8000 / 4796;

            if(isPC) {
                IMG_SIZES.bottle.w = GAME_CONFIG.pc.bottleWidth;
                IMG_SIZES.bottle.h = IMG_SIZES.bottle.w * heightRatio;
                IMG_SIZES.cap.w = GAME_CONFIG.pc.capSize;
                IMG_SIZES.cap.h = GAME_CONFIG.pc.capSize;
                CAP_START_Y = VH - GAME_CONFIG.pc.bottleBottom;
                CAP_OFFSET = GAME_CONFIG.pc.capYOffset;
            }
            else {
                IMG_SIZES.bottle.w = GAME_CONFIG.mobile.bottleWidth;
                IMG_SIZES.bottle.h = IMG_SIZES.bottle.w * heightRatio;
                IMG_SIZES.cap.w = GAME_CONFIG.mobile.capSize;
                IMG_SIZES.cap.h = GAME_CONFIG.mobile.capSize;
                CAP_START_Y = VH - GAME_CONFIG.mobile.bottleBottom;
                CAP_OFFSET = GAME_CONFIG.mobile.capYOffset;
            }

            if(state.phase === 'idle') bottle.y = CAP_START_Y;
            scale = Math.min(w / VW, h / VH);
        }

        // Initialize
        loadAssets();

    </script>
</body>
</html>
